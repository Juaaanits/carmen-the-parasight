rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // Helper functions for validation
    function isAuthenticated() {
      return request.auth != null;
    }
    
    function isOwner(userId) {
      return request.auth.uid == userId;
    }
    
    function isValidEmail(email) {
      return email is string 
        && email.matches('^[a-zA-Z0-9.!#$%&\'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$')
        && email.size() <= 254;
    }
    
    function isValidName(name) {
      return name is string 
        && name.size() > 0 
        && name.size() <= 50
        && name.matches('^[a-zA-ZÀ-ÿ\\u0100-\\u017F\\u0180-\\u024F\\u1E00-\\u1EFF\\s\'-]+$');
    }
    
    function isValidPhone(phone) {
      return phone is string 
        && phone.size() >= 10 
        && phone.size() <= 20
        && phone.matches('^[\\+]?[1-9][\\d\\s\\-\\(\\)\\.]{8,}$');
    }
    
    function isValidAddress(address) {
      return address is string 
        && address.size() > 0 
        && address.size() <= 200
        && address.matches('^[a-zA-Z0-9\\s\\-\\.,#\\/]+$');
    }
    
    function isValidBio(bio) {
      return bio is string 
        && bio.size() <= 500
        && bio.matches('^[a-zA-Z0-9\\s\\-\\.,!?\'\"()&@#$%\\n\\r]*$');
    }
    
    function isValidMedicalCondition(condition) {
      return condition is string 
        && condition.size() > 0 
        && condition.size() <= 100
        && condition.matches('^[a-zA-Z0-9\\s\\-\\(\\)\\.]+$');
    }
    
    function isValidCategory(category) {
      return category is string 
        && category in ['speech', 'physical', 'mental', 'other'];
    }
    
    function isValidDocumentName(name) {
      return name is string 
        && name.size() > 0 
        && name.size() <= 100
        && name.matches('^[a-zA-Z0-9\\s\\-\\._]+$');
    }
    
    function isValidDateOfBirth(dob) {
      return dob is string 
        && dob.matches('^\\d{4}-\\d{2}-\\d{2}$');
    }
    
    function isValidUserType(userType) {
      return userType is string 
        && userType in ['patient', 'doctor', 'admin', 'nurse', 'clinic_staff'];
    }
    
    function isValidRole(role) {
      return role is string 
        && role in ['patient', 'doctor', 'admin', 'nurse', 'clinic_staff'];
    }
    
    function getUserRole(userId) {
      return get(/databases/$(database)/documents/users/$(userId)).data.role;
    }
    
    function isEmailVerified() {
      return request.auth != null && 
        (request.auth.token.email_verified == true || 
         request.auth.token.firebase.sign_in_provider == 'google.com');
    }
    
    function hasRole(role) {
      return request.auth != null && getUserRole(request.auth.uid) == role;
    }
    
    function hasAnyRole(roles) {
      return request.auth != null && getUserRole(request.auth.uid) in roles;
    }
    
    function isValidAuthProvider(provider) {
      return provider is string 
        && provider in ['email', 'google', 'facebook'];
    }
    
    function isValidLanguage(lang) {
      return lang is string 
        && lang in ['en', 'fil', 'es', 'fr', 'de'];
    }
    
    function isValidTheme(theme) {
      return theme is string 
        && theme in ['light', 'dark', 'auto'];
    }
    
    // Validate patient data structure
    function isValidPatientData(data) {
      return data.keys().hasAll(['uid', 'email', 'userType', 'personalInfo', 'medicalInfo', 'settings', 'activity', 'createdAt', 'lastLoginAt', 'isActive'])
        && isValidEmail(data.email)
        && data.uid is string
        && data.uid.size() > 0
        && isValidUserType(data.userType)
        && data.userType == 'patient'
        && isValidPersonalInfo(data.personalInfo)
        && isValidMedicalInfo(data.medicalInfo)
        && isValidSettings(data.settings)
        && isValidActivity(data.activity)
        && data.createdAt is timestamp
        && data.lastLoginAt is timestamp
        && data.isActive is bool
        && (data.authProvider == null || isValidAuthProvider(data.authProvider))
        && (data.emailVerified == null || data.emailVerified is bool)
        && (data.profileComplete == null || data.profileComplete is bool);
    }
    
    function isValidPersonalInfo(info) {
      return info is map
        && (info.firstName == null || isValidName(info.firstName))
        && (info.lastName == null || isValidName(info.lastName))
        && (info.fullName == null || isValidName(info.fullName))
        && (info.phone == null || isValidPhone(info.phone))
        && (info.address == null || isValidAddress(info.address))
        && (info.bio == null || isValidBio(info.bio))
        && (info.dateOfBirth == null || isValidDateOfBirth(info.dateOfBirth))
        && (info.age == null || (info.age is number && info.age >= 13 && info.age <= 120))
        && (info.gender == null || (info.gender is string && info.gender in ['male', 'female', 'other', 'prefer_not_to_say']))
        && (info.location == null || (info.location is string && info.location.size() <= 100));
    }
    
    function isValidMedicalInfo(info) {
      return info is map
        && (info.conditions == null || isValidConditions(info.conditions))
        && (info.allergies == null || info.allergies is list)
        && (info.medications == null || info.medications is list)
        && (info.emergencyContact == null || isValidEmergencyContact(info.emergencyContact));
    }
    
    function isValidConditions(conditions) {
      return conditions is map
        && (conditions.speech == null || (conditions.speech is list && conditions.speech.size() <= 10))
        && (conditions.physical == null || (conditions.physical is list && conditions.physical.size() <= 10))
        && (conditions.mental == null || (conditions.mental is list && conditions.mental.size() <= 10))
        && (conditions.other == null || (conditions.other is list && conditions.other.size() <= 10));
    }
    
    function isValidEmergencyContact(contact) {
      return contact is map
        && (contact.name == null || isValidName(contact.name))
        && (contact.phone == null || isValidPhone(contact.phone))
        && (contact.relationship == null || (contact.relationship is string && contact.relationship.size() <= 50));
    }
    
    function isValidSettings(settings) {
      return settings is map
        && (settings.notifications == null || settings.notifications is bool)
        && (settings.language == null || isValidLanguage(settings.language))
        && (settings.theme == null || isValidTheme(settings.theme))
        && (settings.privacy == null || isValidPrivacySettings(settings.privacy));
    }
    
    function isValidPrivacySettings(privacy) {
      return privacy is map
        && (privacy.shareData == null || privacy.shareData is bool)
        && (privacy.allowResearch == null || privacy.allowResearch is bool);
    }
    
    function isValidActivity(activity) {
      return activity is map
        && (activity.consultationHistory == null || activity.consultationHistory is list)
        && (activity.documents == null || activity.documents is list)
        && (activity.appointments == null || activity.appointments is list);
    }
    
    // Rate limiting helper
    function isNotRateLimited() {
      // This is a simplified check - in production, use a more sophisticated rate limiting system
      return true;
    }
    
    // Users collection - general user data with role-based access
    match /users/{userId} {
      // Users can read their own data
      allow read: if isAuthenticated() && isOwner(userId);
      
      // Admins can read all user data
      allow read: if isAuthenticated() && hasRole('admin');
      
      // Create user document (allow initial creation without email verification)
      allow create: if isAuthenticated() 
        && isOwner(userId)
        && isNotRateLimited()
        && request.resource.data.keys().hasAll(['uid', 'email', 'role', 'createdAt'])
        && request.resource.data.uid == userId
        && isValidEmail(request.resource.data.email)
        && isValidRole(request.resource.data.role)
        && request.resource.data.createdAt == request.time
        && (request.resource.data.authProvider == null || isValidAuthProvider(request.resource.data.authProvider))
        && (request.resource.data.isActive == null || request.resource.data.isActive is bool)
        && (request.resource.data.emailVerified == null || request.resource.data.emailVerified is bool);
      
      // Update user data (role can only be changed by admin)
      allow update: if isAuthenticated() 
        && isOwner(userId)
        && isNotRateLimited()
        && request.resource.data.uid == resource.data.uid
        && request.resource.data.email == resource.data.email
        && request.resource.data.createdAt == resource.data.createdAt
        && (request.resource.data.role == resource.data.role || hasRole('admin'));
      
      // Admin can update any user's role
      allow update: if isAuthenticated() 
        && hasRole('admin')
        && isNotRateLimited()
        && request.resource.data.uid == resource.data.uid
        && request.resource.data.email == resource.data.email
        && request.resource.data.createdAt == resource.data.createdAt;
      
      allow delete: if false; // Users cannot be deleted via client
    }
    
    // Patients collection - detailed patient data with email verification
    match /patients/{patientId} {
      // Patients can read their own data (must be verified)
      allow read: if isAuthenticated() 
        && isOwner(patientId)
        && isEmailVerified();
      
      // Healthcare providers can read patient data
      allow read: if isAuthenticated() 
        && isEmailVerified()
        && hasAnyRole(['doctor', 'nurse', 'admin']);
      
      // Create patient data (email verification required, Google users are auto-verified)
      allow create: if isAuthenticated() 
        && isOwner(patientId)
        && isEmailVerified()
        && isNotRateLimited()
        && isValidPatientData(request.resource.data)
        && request.resource.data.uid == patientId
        && request.resource.data.createdAt == request.time
        && request.resource.data.lastLoginAt == request.time;
      
      // Patients can update their own data (must be verified)
      allow update: if isAuthenticated() 
        && isOwner(patientId)
        && isEmailVerified()
        && isNotRateLimited()
        && isValidPatientData(request.resource.data)
        && request.resource.data.uid == resource.data.uid
        && request.resource.data.email == resource.data.email
        && request.resource.data.userType == resource.data.userType
        && request.resource.data.createdAt == resource.data.createdAt
        && request.resource.data.lastLoginAt is timestamp;
      
      // Doctors can update patient data
      allow update: if isAuthenticated() 
        && isEmailVerified()
        && hasAnyRole(['doctor', 'admin'])
        && isNotRateLimited()
        && isValidPatientData(request.resource.data)
        && request.resource.data.uid == resource.data.uid
        && request.resource.data.email == resource.data.email
        && request.resource.data.userType == resource.data.userType
        && request.resource.data.createdAt == resource.data.createdAt;
      
      allow delete: if false; // Patients cannot be deleted via client
    }
    
    // Medical conditions subcollection
    match /patients/{patientId}/conditions/{conditionId} {
      allow read, write: if isAuthenticated() 
        && isOwner(patientId)
        && isNotRateLimited();
    }
    
    // Documents subcollection
    match /patients/{patientId}/documents/{documentId} {
      allow read: if isAuthenticated() 
        && (isOwner(patientId) || 
            (request.auth.token.role != null && request.auth.token.role in ['doctor', 'admin']));
      
      allow create: if isAuthenticated() 
        && isOwner(patientId)
        && isNotRateLimited()
        && request.resource.data.keys().hasAll(['name', 'type', 'uploadDate', 'createdAt'])
        && isValidDocumentName(request.resource.data.name)
        && request.resource.data.type is string
        && request.resource.data.uploadDate is string
        && request.resource.data.createdAt == request.time
        && (request.resource.data.size == null || (request.resource.data.size is number && request.resource.data.size > 0))
        && (request.resource.data.url == null || request.resource.data.url is string);
      
      allow update: if isAuthenticated() 
        && isOwner(patientId)
        && isNotRateLimited()
        && request.resource.data.createdAt == resource.data.createdAt;
      
      allow delete: if isAuthenticated() 
        && isOwner(patientId)
        && isNotRateLimited();
    }
    
    // Consultations subcollection
    match /patients/{patientId}/consultations/{consultationId} {
      allow read: if isAuthenticated() 
        && isEmailVerified()
        && (isOwner(patientId) || 
            hasAnyRole(['doctor', 'nurse', 'admin']));
      
      allow create: if isAuthenticated() 
        && isEmailVerified()
        && (isOwner(patientId) || 
            hasAnyRole(['doctor', 'admin']))
        && isNotRateLimited()
        && request.resource.data.keys().hasAll(['date', 'doctor', 'type', 'status', 'createdAt'])
        && request.resource.data.date is string
        && request.resource.data.doctor is string
        && request.resource.data.type is string
        && request.resource.data.status in ['scheduled', 'completed', 'cancelled']
        && request.resource.data.createdAt == request.time;
      
      allow update: if isAuthenticated() 
        && isEmailVerified()
        && hasAnyRole(['doctor', 'nurse', 'admin'])
        && isNotRateLimited();
      
      allow delete: if false; // Consultations cannot be deleted
    }
    
    // Appointments subcollection
    match /patients/{patientId}/appointments/{appointmentId} {
      allow read: if isAuthenticated() 
        && isEmailVerified()
        && (isOwner(patientId) || 
            hasAnyRole(['doctor', 'nurse', 'clinic_staff', 'admin']));
      
      allow create: if isAuthenticated() 
        && isEmailVerified()
        && (isOwner(patientId) || 
            hasAnyRole(['doctor', 'clinic_staff', 'admin']))
        && isNotRateLimited()
        && request.resource.data.keys().hasAll(['date', 'time', 'doctor', 'type', 'status', 'createdAt'])
        && request.resource.data.date is string
        && request.resource.data.time is string
        && request.resource.data.doctor is string
        && request.resource.data.type is string
        && request.resource.data.status in ['scheduled', 'completed', 'cancelled', 'rescheduled']
        && request.resource.data.createdAt == request.time;
      
      allow update: if isAuthenticated() 
        && isEmailVerified()
        && (isOwner(patientId) || 
            hasAnyRole(['doctor', 'nurse', 'clinic_staff', 'admin']))
        && isNotRateLimited();
      
      allow delete: if isAuthenticated() 
        && isEmailVerified()
        && isOwner(patientId)
        && isNotRateLimited();
    }
    
    // Audit log collection (write-only for security)
    match /audit_logs/{logId} {
      allow read: if false; // Only server can read audit logs
      allow write: if isAuthenticated(); // Allow authenticated users to write audit logs
    }
    
    // System collections (admin only)
    match /system/{document=**} {
      allow read, write: if isAuthenticated() 
        && isEmailVerified()
        && hasRole('admin');
    }
    
    // Medical records - strict access control
    match /medical_records/{recordId} {
      // Only patients can read their own records
      allow read: if isAuthenticated() 
        && isEmailVerified()
        && resource.data.patientId == request.auth.uid;
      
      // Only doctors can write medical records
      allow write: if isAuthenticated() 
        && isEmailVerified()
        && hasAnyRole(['doctor', 'admin']);
    }
    
    // Audit logs - admin only
    match /audit_logs/{logId} {
      allow read, write: if isAuthenticated() 
        && isEmailVerified()
        && hasRole('admin');
    }
    
    // Notifications - role-based access
    match /notifications/{notificationId} {
      allow read: if isAuthenticated() 
        && isEmailVerified()
        && (resource.data.recipientId == request.auth.uid || 
            hasRole('admin'));
      
      allow write: if isAuthenticated() 
        && isEmailVerified()
        && hasAnyRole(['doctor', 'nurse', 'clinic_staff', 'admin']);
    }
    
    // Deny all other access
    match /{document=**} {
      allow read, write: if false;
    }
  }
} 